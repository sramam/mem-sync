{"version":3,"file":"background.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://mem-sync/./src/utils/getHash.ts","webpack://mem-sync/webpack/bootstrap","webpack://mem-sync/webpack/runtime/define property getters","webpack://mem-sync/webpack/runtime/hasOwnProperty shorthand","webpack://mem-sync/webpack/runtime/make namespace object","webpack://mem-sync/./src/background/index.ts"],"sourcesContent":["// We need a simple hash function to cache in the browser extension context.\n// High security is not the biggest problem, reasonably collision resistant\n// should suffice.\n/**\n * A fast and simple 53-bit string hash function with decent collision resistance.\n * Largely inspired by MurmurHash2/3, but with a focus on speed/simplicity.\n *\n * https://github.com/bryc/code/blob/master/jshash/experimental/cyrb53.js\n */\nconst cyrb53a = function (str, seed = 0) {\n    let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;\n    for (let i = 0, ch; i < str.length; i++) {\n        ch = str.charCodeAt(i);\n        h1 = Math.imul(h1 ^ ch, 0x85ebca77);\n        h2 = Math.imul(h2 ^ ch, 0xc2b2ae3d);\n    }\n    h1 ^= Math.imul(h1 ^ (h2 >>> 15), 0x735a2d97);\n    h2 ^= Math.imul(h2 ^ (h1 >>> 15), 0xcaf649a9);\n    h1 ^= h2 >>> 16;\n    h2 ^= h1 >>> 16;\n    const hash = 2097152 * (h2 >>> 0) + (h1 >>> 11);\n    return hash.toString(16);\n};\nexport const getHash = cyrb53a;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { getHash } from \"../utils/getHash\";\nconst cache = {};\nlet popupReady = false;\nchrome.runtime.onMessage.addListener(async (request, sender, sendResponse) => {\n    if (request.action === \"sendDomDetails\") {\n        sendResponse({ status: \"ok\" });\n        const domDetails = request.data;\n        // from this point on, we'll identify the page by the hash of it's contents.\n        const id = getHash(domDetails.innerText);\n        const { url, ogImage, title, description } = domDetails;\n        const partialPageInfo = {\n            url,\n            ogImage,\n            title,\n            description,\n            tags: [],\n            tldr: \"\",\n            synopsis: \"\",\n        };\n        cache[id] = {\n            id,\n            domDetails,\n            pageInfo: partialPageInfo,\n        };\n        const response = await sendPageInfo(partialPageInfo, id);\n        const summary = await getSummary(domDetails.innerText, id);\n        console.log(summary);\n    }\n    else if (request.action === \"popupRegistration\") {\n        popupReady = true;\n        const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n        await chrome.tabs.sendMessage(tabs[0].id, { action: \"getDomDetails\" });\n        sendResponse({ status: \"ok\" });\n    }\n});\n/**\n * sends collated pageInfo to popup.js\n */\nexport async function sendPageInfo(pageInfo, id) {\n    const _send = () => {\n        const message = {\n            action: \"sendPageInfo\",\n            id,\n            pageInfo,\n        };\n        return chrome.runtime.sendMessage(message, (response) => {\n            // nothing to do here. perhaps delete the data from cache?\n        });\n    };\n    const wait = () => setTimeout(() => {\n        if (popupReady) {\n            _send();\n        }\n        else {\n            wait();\n        }\n    }, 100);\n    wait();\n}\n// This is a total hack. We should send this from the settings.\n// An open question to ask here is should it be configurable?\nconst SERVER_URL = \"http://localhost:3000\";\n/**\n * Asks server to summarize text via openAI\n */\nexport async function getSummary(text, id) {\n    console.log(`getSummary`);\n    const body = {\n        id,\n        text,\n    };\n    const response = await fetch(`${SERVER_URL}/get_summary`, {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(body),\n    });\n    if (response.ok) {\n        console.log(`getSummary SUCCESS`);\n        const { id, ...pageSummary } = await response.json();\n        // we should now have the pageSummary from LLM.\n        const prev = cache[id];\n        const { tags, tldr, synopsis } = pageSummary;\n        const fullPageInfo = {\n            ...prev.pageInfo,\n            tags,\n            tldr,\n            synopsis,\n        };\n        cache[id] = {\n            ...prev,\n            pageSummary,\n            pageInfo: fullPageInfo,\n        };\n        // and the final call to sendPageInfo\n        await sendPageInfo(fullPageInfo, id);\n    }\n    else {\n        console.log(`getSummary ERROR`);\n    }\n}\n/**\n * We need this to trigger the backgrou\n */\nchrome.runtime.onMessage.addListener(async (message, sender, sendResponse) => {\n    if (message.action === \"triggerMemSave\") {\n        const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n        console.log(`triggerMemSave:`, tabs);\n        sendResponse({ status: \"ok\" });\n    }\n});\n"],"names":[],"sourceRoot":""}